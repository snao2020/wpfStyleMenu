#include <windows.h>
#include <windowsx.h>

#include "ContextMenuHandler.h"	 
#include "MenuHelper.h"


static BOOL HookWmMenuSelect(MSG* pMsg);
static BOOL HookWmKeyDown(MSG* pMsg);
static BOOL HookWmRegPostKeyDown(MSG* pMsg);
static BOOL HookWmChar(MSG* pMsg);
static BOOL HookWmMouseMove(MSG* pMsg);
static BOOL HookWmMouseButtonDown(MSG* pMsg);


void ContextMenuHandler_Setup()
{
}


void ContextMenuHandler_Cleanup()
{
}


BOOL ContextMenuHandler_MsgFilterProc(MSG* pMsg)
{
	BOOL result = 0;
	if(pMsg)
	{
		if (pMsg->message == RegPostKeyDown())
			result = HookWmRegPostKeyDown(pMsg);
		else
		{
			switch (pMsg->message)
			{
			case WM_MENUSELECT:		result = HookWmMenuSelect(pMsg); break;
			case WM_KEYDOWN:		result = HookWmKeyDown(pMsg); break;
			case WM_CHAR:			result = HookWmChar(pMsg); break;
			case WM_MOUSEMOVE:		result = HookWmMouseMove(pMsg); break;
			case WM_LBUTTONDOWN:
			case WM_RBUTTONDOWN:	result = HookWmMouseButtonDown(pMsg); break;
			}
		}
	}
	return result;
}


static BOOL HookWmMenuSelect(MSG* pMsg)
{
	BOOL cancel = FALSE;

	HWND hwnd = pMsg->hwnd;
	HMENU hmenu = (HMENU)pMsg->lParam;
	//int item = HIWORD(pMsg->wParam) & MF_POPUP ? 0L : (int)LOWORD(pMsg->wParam);
	//HMENU hmenuPopup = HIWORD(pMsg->wParam) & MF_POPUP ? GetSubMenu((HMENU)pMsg->lParam, LOWORD(pMsg->wParam)) : 0L;
	UINT flags = (UINT)((short)HIWORD(pMsg->wParam) == -1 ? 0xFFFFFFFF : HIWORD(pMsg->wParam));

	PopupMenuItem* pPMI = PopupMenuList_FindItem(hmenu);
	if (pPMI)
	{
		// Open a cascading menu generated by VK_RIGHT, first item will be selected.
		// If first item has MF_GRAYED or MF_DISABLED,
		// move selection to a enabled item.
		
		if(!PopupMenuItem_IsFlagSet(pPMI, PMI_FIRSTMSGDONE))
		{
			PopupMenuItem_SetFlag(pPMI, PMI_FIRSTMSGDONE);

			int pos = GetHilitePos(hmenu);
			if(pos >= 0)
				PopupMenuItem_SetKeyboardSelection(pPMI, pos);

			if (flags != UINT_MAX && flags & (MF_GRAYED | MF_DISABLED))
			{
				if (GetFirstEnabled(hmenu) < 0)
				{
					cancel = TRUE;
					SendMessage(PopupMenuItem_GetHWnd(pPMI), mn_selectitem, (WPARAM)-1, 0);
				}
				else
					PostMessage(hwnd, WM_KEYDOWN, VK_DOWN, 0);
			}
		}	
	}
	return cancel;
}


static BOOL HookWmKeyDown(MSG* pMsg)
{
	BOOL cancel = FALSE;

	HWND hwnd = pMsg->hwnd;
	UINT vk = (UINT)pMsg->wParam;
	//int cRepeat = (int)(short)LOWORD(pMsg->lParam);
	//UINT flags = (UINT)HIWORD(pMsg->lParam);

	PopupMenuItem* pPMI = PopupMenuList_GetTop();
	if (pPMI)
	{
		PopupMenuItem_SetFlag(pPMI, PMI_FIRSTMSGDONE);

		HWND hwndPopup = PopupMenuItem_GetHWnd(pPMI);
		HMENU hmenuPopup = (HMENU)SendMessage(hwndPopup, MN_GETHMENU, 0, 0);
		if (hmenuPopup)
		{
			int sel;
			switch (vk)
			{			
			case VK_RETURN:
				sel = GetHilitePos(hmenuPopup);
				if (sel < 0)
					cancel = TRUE;
				break;

			case VK_UP:
			case VK_DOWN:
				if (GetFirstEnabled(hmenuPopup) < 0)
					cancel = TRUE;
				else
				{
					int pos = PopupMenuItem_GetKeyboardSelection(pPMI);

					// menuitem at pos may not have MF_HILITE
					if (pos >= 0)
						SendMessage(hwndPopup, mn_selectitem, pos, 0);

					PostMessage(hwnd, RegPostKeyDown(), vk, (LPARAM)hmenuPopup);
				}
				break;
			}
		}
	}
	return cancel;
}


static BOOL HookWmRegPostKeyDown(MSG* pMsg)
{
	UINT vk = pMsg->wParam;
	HMENU hmenu = (HMENU)pMsg->lParam;
	
	if (vk == VK_UP || vk == VK_DOWN)
	{
		PopupMenuItem* pPMI = PopupMenuList_GetTop();
		if (pPMI)
		{
			HWND hwndPopup = PopupMenuItem_GetHWnd(pPMI);
			HMENU hmenuPopup = (HMENU)SendMessage(hwndPopup, MN_GETHMENU, 0, 0);
			if (hmenuPopup == hmenu)
			{
				int pos = GetHilitePos(hmenu);
				if (pos >= 0)
				{
					PopupMenuItem_SetKeyboardSelection(pPMI, pos);

					UINT state = GetMenuState(hmenu, pos, MF_BYPOSITION);
					if (state != UINT_MAX && state & (MF_GRAYED | MF_DISABLED))
						PostMessage(pMsg->hwnd, WM_KEYDOWN, vk, 0);
				}
			}
		}
	}
	return TRUE;
}


static BOOL HookWmChar(MSG* pMsg)
{
	BOOL cancel = FALSE;
	PopupMenuItem* pPMI = PopupMenuList_GetTop();
	if (pPMI)
	{
		HWND hwndPopup = PopupMenuItem_GetHWnd(pPMI);
		HMENU hmenuPopup = (HMENU)SendMessage(hwndPopup, MN_GETHMENU, 0, 0);
		int pos = GetMnemonicItem(hmenuPopup, (TCHAR)pMsg->wParam);
		if (pos >= 0)
		{
			UINT state = GetMenuState(hmenuPopup, pos, MF_BYPOSITION);
			if (state != UINT_MAX && state & (MF_GRAYED | MF_DISABLED))
				cancel = TRUE;
		}
	}
	return cancel;
}


static BOOL HookWmMouseMove(MSG* pMsg)
{
	BOOL cancel = FALSE;

	HWND hwnd = pMsg->hwnd;
	//int x = GET_X_LPARAM(pMsg->lParam);
	//int y = GET_Y_LPARAM(pMsg->lParam);
	//UINT keyFlags = (UINT)pMsg->wParam;

	POINT ptScreen;
	ptScreen.x = GET_X_LPARAM(pMsg->lParam);
	ptScreen.y = GET_Y_LPARAM(pMsg->lParam);

	PopupMenuItem* pPMI = PopupMenuList_HitTest(&ptScreen);
	if(pPMI)
	{
		PopupMenuItem_SetFlag(pPMI, PMI_FIRSTMSGDONE);

		HWND hwndPopup = PopupMenuItem_GetHWnd(pPMI);
		HMENU hmenuPopup = (HMENU)SendMessage(hwndPopup, MN_GETHMENU, 0, 0);
		if (hmenuPopup)
		{
			int mouseSel = MenuItemFromPoint(hwnd, hmenuPopup, ptScreen);
			if (mouseSel >= 0)
			{
				UINT state = GetMenuState(hmenuPopup, mouseSel, MF_BYPOSITION);
				if(state != UINT_MAX && state & (MF_GRAYED | MF_DISABLED))
					mouseSel = -1;
			}
			int oldMouseSel = PopupMenuItem_GetMouseSelection(pPMI);
			int keyboardSel = PopupMenuItem_GetKeyboardSelection(pPMI);

			if (mouseSel != oldMouseSel)
			{
				PopupMenuItem_SetMouseSelection(pPMI, mouseSel);
				if (mouseSel >= 0)
				{
					if (mouseSel != keyboardSel)
						PopupMenuItem_SetKeyboardSelection(pPMI, mouseSel);
				}
				else
				{
					cancel = TRUE;
					if (oldMouseSel == keyboardSel)
						SendMessage(hwndPopup, mn_selectitem, (WPARAM)mouseSel, 0);
				}
			}
			// if menu item is popupmenu, mn_settimertoopenhierarchy will be generated.
			else if(mouseSel != keyboardSel || mouseSel < 0)
				cancel = TRUE;
		}
	}
	return cancel;
}


// Default behavior of WM_LBUUTONDOWN/WM_RBUTTONDOWN sets MF_HILITE on.
// If a menu item has MF_GRAYED or MF_DISABLED,
// WM_LBUTTONDOWN or WM_RBUTTONDOWN add MF_HILITE to the menu item
// and menu is still visible.

static BOOL HookWmMouseButtonDown(MSG* pMsg)
{
	BOOL cancel = FALSE;

	HWND hwnd = pMsg->hwnd;
	//int x = GET_X_LPARAM(pMsg->lParam);
	//int y = GET_Y_LPARAM(pMsg->lParam);
	//UINT keyFlags = (UINT)pMsg->wParam;

	POINT ptScreen;
	ptScreen.x = GET_X_LPARAM(pMsg->lParam);
	ptScreen.y = GET_Y_LPARAM(pMsg->lParam);

	PopupMenuItem* pPMI = PopupMenuList_HitTest(&ptScreen);
	if (pPMI)
	{
		PopupMenuItem_SetFlag(pPMI, PMI_FIRSTMSGDONE);

		HWND hwndPopup = PopupMenuItem_GetHWnd(pPMI);
		HMENU hmenuPopup = (HMENU)SendMessage(hwndPopup, MN_GETHMENU, 0, 0);// GetHMenuPopup(hwndPopup);
		if (hmenuPopup)
		{
			int pos = MenuItemFromPoint(hwnd, hmenuPopup, ptScreen);
			if (pos >= 0)
			{
				UINT state = GetMenuState(hmenuPopup, pos, MF_BYPOSITION);
				if (state != UINT_MAX && state & (MF_GRAYED | MF_DISABLED))
					cancel = TRUE;
			}
		}
	}
	return cancel;
}




